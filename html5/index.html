<html>
	<head>
		<style>
			* {
				margin: 0;
				padding: 0;
			}
		
			html {
				/*background-color: #1e1e1e;*/
				/*background-color: skyblue;*/
			}
		
			body {
				/*background-color: DodgerBlue;*/
				/*color: white;*/
				/*
				
				
				*/
				width: 980px;
				margin: auto;
				padding: 10px;
				border-left:  4px solid aliceblue;
				border-right: 4px solid aliceblue;
			}
		
			textarea {
				width: 100%;
				background: transparent;
				border: 0px solid black;
				border: 0px solid black;
				border: 0px solid black;
			}

			test-js table {
				width: 100%;
				margin-bottom: 5px;
				padding: 5px;
				border-radius: 10px;
				border: 2px solid black;
				background-color: #e1e1e8;
			}
			
			test-js td {
			}
			
			test-js th {
				background-color: aliceblue;
			}
			
			.testcode {
			}
			
			.testresult {
				width: 100px;
			}
			
			.testbutton {
				width: 60px;
			}
			
			.testbutton button {
				width: 50px;
			}
		</style>
	
		<script src="utils.js"></script>
		<script src="Tests.js"></script>
		<script src="Loader.js"></script>

		<script>

			function fetch_script(url) {
				return new Promise(function(resolve, reject) {
					var script = document.createElement("script");
					script.type = "text/javascript";
					script.onload = function () {
						resolve(script);
					};
					script.src = url /* + "?now=" + Date.now()*/;
					document.head.appendChild(script);
				});
			}

			async function main() {
				response = await fetch("../build/untouched.wasm");
				//buffer = await response.arrayBuffer();
				
				imports = {};
				
				/*
				imports.env = {};
				imports.env.memoryBase = 0;
				imports.env.tableBase = 0;
				if (!imports.env.memory) {
					imports.env.memory = new WebAssembly.Memory({ initial: 20 });
				}
				if (!imports.env.table) {
					imports.env.table = new WebAssembly.Table({ initial: 0, element: 'anyfunc' });
				}
				*/
				
				//module = Loader.instantiateBuffer(buffer, imports);
				module = await Loader.instantiateStreaming(response, imports);
				
				//console.log(module.I8.length);
				
				// next three lines just test the auto-generated demangled class, which isn't so useful currently
				// this PR might change it: https://github.com/AssemblyScript/assemblyscript/pull/437
				// a = new module.Vec3(1,2,3)
				// b = new module.Vec3(11,22,33)
				// console.log("a.add(b)", a.add(b)); // returns no class but a raw pointer
				
				pc = {}; // namespace for all pc_*.js files
				await fetch_script("pc_mat3.js");
				await fetch_script("pc_mat4.js");
				await fetch_script("pc_quat.js");
				await fetch_script("pc_vec2.js");
				await fetch_script("pc_vec3.js");
				await fetch_script("pc_vec4.js");
				
				tests_init();
			}

			main().then(function() {
				console.log("main() called");
			});

		</script>
	</head>
	<body>
		<h1>Legend</h1>
		<!--
		todo lol
		<h2>CTRL + Arrow Up: Focus previous textarea</h2>
		<h2>CTRL + Arrow Down: Focus next textarea</h2>
		-->
		<h2>CTRL + Enter: Re<i>e</i>valuate the test code</h2>

		<tests-js>
			<h1>Mat3 stuff</h1>		
			
			<test-js>
				var a = new pc.Mat3();
				a.toString() == "[1, 0, 0, 0, 1, 0, 0, 0, 1]";
			</test-js>
			
			<test-js>
				var a = new pc.Mat3();
				a.data[0] = 1;
				a.data[1] = 2;
				a.data[2] = 3;
				var b = new pc.Mat3();
				b.copy(a);
				b.toString() == "[1, 2, 3, 0, 1, 0, 0, 0, 1]";
			</test-js>
			
			<test-js>
				var a = new pc.Mat3();
				a.set([0, 1, 2, 3, 4, 5, 6, 7, 8]);
				a.toString() == "[0, 1, 2, 3, 4, 5, 6, 7, 8]";
			</test-js>
			
			<test-js>
				var a = new pc.Mat3();
				a.data[0] = 1;
				a.data[1] = 2;
				a.data[2] = 3;
				var b = new pc.Mat3();
				var c = new pc.Mat3();
				!a.equals(b) && b.equals(c);
			</test-js>
			
			<test-js>
				var a = new pc.Mat3();
				a.data[0] = 1;
				a.data[1] = 2;
				a.data[2] = 3;
				var b = new pc.Mat3();
				!a.isIdentity() && b.isIdentity();
			</test-js>
			
			<test-js>
				var a = new pc.Mat3();
				a.data[0] = 1;
				a.data[1] = 2;
				a.data[2] = 3;
				a.setIdentity();
				a.toString() == "[1, 0, 0, 0, 1, 0, 0, 0, 1]";
			</test-js>
			
			<test-js>
				var a = new pc.Mat3();
				a.set([0, 1, 2, 3, 4, 5, 6, 7, 8]);
				a.transpose();
				a.toString() == "[0, 3, 6, 1, 4, 7, 2, 5, 8]";
			</test-js>
			
			<test-js>
				pc.Mat3.IDENTITY.toString() == "[1, 0, 0, 0, 1, 0, 0, 0, 1]";
			</test-js>
			
			<test-js>
				pc.Mat3.ZERO.toString() == "[0, 0, 0, 0, 0, 0, 0, 0, 0]";
			</test-js>
			
			<test-js>
			</test-js>
		</tests-js>



		<tests-js>
			<h1>Mat4 stuff</h1>		
			
			<test-js>
				var a = new pc.Mat4();
				a.toString() == "[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]";
			</test-js>
			
			<test-js>
				var a = new pc.Mat4();
				a.add(pc.Mat4.ONE);
				a.toString() == "[2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2]";
			</test-js>
			
			<test-js>
				var m = new pc.Mat4();
				m.add2(pc.Mat4.IDENTITY, pc.Mat4.ONE);
				m.toString() == "[2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2]";
			</test-js>
			
			<test-js>
				var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
				var b = a.clone();
				var c = new pc.Mat4();
				a.equals(b) && !b.equals(c);
			</test-js>
			
			<test-js>
				var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
				var b = new pc.Mat4();
				b.copy(a);
				a.equals(b);
			</test-js>
			
			<test-js>
				var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
				var b = new pc.Mat4();
				!a.equals(b) && a.equals(a);
			</test-js>
			
			<test-js>
				var m = new pc.Mat4().setScale(2, 3, 4);
				m.getScale().toString() == "[2, 3, 4]";
			</test-js>
			
			<test-js>
				var m = new pc.Mat4().setTranslate(2, 3, 4);
				var t = new pc.Vec3();
				m.getTranslation(t).toString() == "[2, 3, 4]";
			</test-js>
			
			<test-js>
				var m = new pc.Mat4();
				var x = new pc.Vec3();
				m.getX(x).toString() == "[1, 0, 0]";
			</test-js>
			
			<test-js>
				var m = new pc.Mat4();
				var y = new pc.Vec3();
				m.getY(y).toString() == "[0, 1, 0]";
			</test-js>
			
			<test-js>
				var m = new pc.Mat4();
				var z = new pc.Vec3();
				m.getZ(z).toString() == "[0, 0, 1]";
			</test-js>
			
			<test-js>
				// Create a 4x4 rotation matrix of 180 degrees around the y-axis
				var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
				// Invert in place
				rot.invert();
			</test-js>
			
			<test-js>
				var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
				rot.invertTo3x3
			</test-js>
			
			<test-js>
				var m = new pc.Mat4();
				console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
			</test-js>
			
			<test-js>
				var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
				var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
				a.mul(b); // a = a * b
				console.log("The result of the multiplication is: " a.toString());
			</test-js>
			
			<test-js>
				var a = new pc.Mat4().setFromEulerAngles(10, 20, 30);
				var b = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
				var r = new pc.Mat4();
				// r = a * b
				r.mul2(a, b);
				console.log("The result of the multiplication is: " r.toString());
			</test-js>
			
			<test-js>
				// setFromAxisAngle
				
				// @description Sets the specified matrix to a rotation matrix equivalent to a rotation around
				// an axis. The axis must be normalized (unit length) and the angle must be specified in degrees.
				// @param {pc.Vec3} axis The normalized axis vector around which to rotate.
				// @param {f32} angle The angle of rotation in degrees.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// // Create a 4x4 rotation matrix
				// var rm = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 90);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#setFromEulerAngles
				// @description Sets the specified matrix to a rotation matrix defined by
				// Euler angles. The Euler angles are specified in XYZ order and in degrees.
				// @param {f32} ex Angle to rotate around X axis in degrees.
				// @param {f32} ey Angle to rotate around Y axis in degrees.
				// @param {f32} ez Angle to rotate around Z axis in degrees.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// var m = new pc.Mat4();
				// m.setFromEulerAngles(45, 90, 180);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#setFrustum
				// @description Sets the specified matrix to a perspective projection matrix. The function's parameters define
				// the shape of a frustum.
				// @param {f32} left The x-coordinate for the left edge of the camera's projection plane in eye space.
				// @param {f32} right The x-coordinate for the right edge of the camera's projection plane in eye space.
				// @param {f32} bottom The y-coordinate for the bottom edge of the camera's projection plane in eye space.
				// @param {f32} top The y-coordinate for the top edge of the camera's projection plane in eye space.
				// @param {f32} znear The near clip plane in eye coordinates.
				// @param {f32} zfar The far clip plane in eye coordinates.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// // Create a 4x4 perspective projection matrix
				// var f = pc.Mat4().setFrustum(-2, 2, -1, 1, 1, 1000);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#setIdentity
				// @description Sets the specified matrix to the identity matrix.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// m.setIdentity();
				// console.log("The matrix is " + (m.isIdentity() ? "identity" : "not identity"));
			</test-js>
			
			<test-js>
				// @name pc.Mat4#setLookAt
				// @description Sets the specified matrix to a viewing matrix derived from an eye point, a target point
				// and an up vector. The matrix maps the target point to the negative z-axis and the eye point to the
				// origin, so that when you use a typical projection matrix, the center of the scene maps to the center
				// of the viewport. Similarly, the direction described by the up vector projected onto the viewing plane
				// is mapped to the positive y-axis so that it points upward in the viewport. The up vector must not be
				// parallel to the line of sight from the eye to the reference point.
				// @param {pc.Vec3} position 3-d vector holding view position.
				// @param {pc.Vec3} target 3-d vector holding reference point.
				// @param {pc.Vec3} up 3-d vector holding the up direction.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// var position = new pc.Vec3(10, 10, 10);
				// var target = new pc.Vec3(0, 0, 0);
				// var up = new pc.Vec3(0, 1, 0);
				// var m = new pc.Mat4().setLookAt(position, target, up);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#setOrtho
				// @description Sets the specified matrix to an orthographic projection matrix. The function's parameters
				// define the shape of a cuboid-shaped frustum.
				// @param {f32} left The x-coordinate for the left edge of the camera's projection plane in eye space.
				// @param {f32} right The x-coordinate for the right edge of the camera's projection plane in eye space.
				// @param {f32} bottom The y-coordinate for the bottom edge of the camera's projection plane in eye space.
				// @param {f32} top The y-coordinate for the top edge of the camera's projection plane in eye space.
				// @param {f32} near The near clip plane in eye coordinates.
				// @param {f32} far The far clip plane in eye coordinates.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// // Create a 4x4 orthographic projection matrix
				// var ortho = pc.Mat4().ortho(-2, 2, -2, 2, 1, 1000);
			</test-js>
			
			<test-js>
				// pc.Mat4#setPerspective
				// @description Sets the specified matrix to a perspective projection matrix. The function's
				// parameters define the shape of a frustum.
				// @param {f32} fov The frustum's field of view in degrees. The fovIsHorizontal parameter
				// controls whether this is a vertical or horizontal field of view. By default, it's a vertical
				// field of view.
				// @param {f32} aspect The aspect ratio of the frustum's projection plane (width / height).
				// @param {f32} znear The near clip plane in eye coordinates.
				// @param {f32} zfar The far clip plane in eye coordinates.
				// @param {Boolean} [fovIsHorizontal=false] Set to true to treat the fov as horizontal (x-axis)
				// and false for vertical (y-axis). Defaults to false.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// // Create a 4x4 perspective projection matrix
				// var persp = pc.Mat4().setPerspective(45, 16 / 9, 1, 1000);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#setScale
				// @description Sets the specified matrix to a scale matrix.
				// @param {f32} x The x-component of the scale.
				// @param {f32} y The y-component of the scale.
				// @param {f32} z The z-component of the scale.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// // Create a 4x4 scale matrix
				// var sm = new pc.Mat4().setScale(10, 10, 10);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#setTranslate
				// @description Sets the specified matrix to a translation matrix.
				// @param {f32} x The x-component of the translation.
				// @param {f32} y The y-component of the translation.
				// @param {f32} z The z-component of the translation.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// // Create a 4x4 translation matrix
				// var tm = new pc.Mat4().setTranslate(10, 10, 10);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#transformPoint
				// @description Transforms a 3-dimensional point by a 4x4 matrix.
				// @param {pc.Vec3} vec The 3-dimensional point to be transformed.
				// @param {pc.Vec3} [res] An optional 3-dimensional point to receive the result of the transformation.
				// @returns {pc.Vec3} The input point v transformed by the current instance.
				// @example
				// // Create a 3-dimensional point
				// var v = new pc.Vec3(1, 2, 3);
				// 
				// // Create a 4x4 rotation matrix
				// var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
				// 
				// var tv = m.transformPoint(v);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#transformVec4
				// @description Transforms a 4-dimensional vector by a 4x4 matrix.
				// @param {pc.Vec4} vec The 4-dimensional vector to be transformed.
				// @param {pc.Vec4} [res] An optional 4-dimensional vector to receive the result of the transformation.
				// @returns {pc.Vec4} The input vector v transformed by the current instance.
				// @example
				// // Create an input 4-dimensional vector
				// var v = new pc.Vec4(1, 2, 3, 4);
				// 
				// // Create an output 4-dimensional vector
				// var result = new pc.Vec4();
				// 
				// // Create a 4x4 rotation matrix
				// var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
				// 
				// m.transformVec4(v, result);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#transformVector
				// @description Transforms a 3-dimensional vector by a 4x4 matrix.
				// @param {pc.Vec3} vec The 3-dimensional vector to be transformed.
				// @param {pc.Vec3} [res] An optional 3-dimensional vector to receive the result of the transformation.
				// @returns {pc.Vec3} The input vector v transformed by the current instance.
				// @example
				// // Create a 3-dimensional vector
				// var v = new pc.Vec3(1, 2, 3);
				// 
				// // Create a 4x4 rotation matrix
				// var m = new pc.Mat4().setFromEulerAngles(10, 20, 30);
				// 
				// var tv = m.transformVector(v);
			</test-js>
			
			<test-js>
				// @name pc.Mat4#transpose
				// @description Sets the specified matrix to its transpose.
				// @returns {pc.Mat4} Self for chaining.
				// @example
				// var m = new pc.Mat4();
				// 
				// // Transpose in place
				// m.transpose();
			</test-js>
			
			<test-js>
			
			</test-js>
		</tests-js>



		<tests-js>
			<h1>Quat stuff</h1>
			
			<test-js>
				var a = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				a.toStringFixed(4) == "[0.1000, 0.2000, 0.3000, 0.4000]";
			</test-js>
			
			<test-js>
				var a = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				var b = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				var c = new pc.Quat();
				a.equals(b) && !a.equals(c);
			</test-js>
			
			<test-js>
				var a = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				a.conjugate();
				a.toStringFixed(4) == "[-0.1000, -0.2000, -0.3000, 0.4000]";
			</test-js>
			
			<test-js>
				var q = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				var v = new pc.Vec3();
				var angle = q.getAxisAngle(v);
				angle.toFixed(4) == "132.8436";
			</test-js>
			
			<test-js>
				var q = new pc.Quat();
				q.setFromAxisAngle(new pc.Vec3(0, 1, 0), 90);
				var v = new pc.Vec3();
				var angle = q.getAxisAngle(v);
				angle == 90 && v.toString() == "[0, 1, 0]";
			</test-js>
			
			<test-js>
				var q = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				var v = new pc.Vec3();
				q.getEulerAngles(v)
				v.toStringFixed(4) == "[12.5288, 5.7392, 20.7256]";
			</test-js>
			
			<test-js>
				var a = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				a.invert();
				a.toStringFixed(4) == "[-0.1826, -0.3651, -0.5477, 0.7303]";
			</test-js>
			
			<test-js>
				var a = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				a.length().toFixed(4) == 0.5477;
			</test-js>
			
			<test-js>
				var a = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				a.lengthSq().toFixed(4) == "0.3000";
			</test-js>
			
			<test-js>
				var a = new pc.Quat().setFromEulerAngles(0, 10, 0);
				var b = new pc.Quat().setFromEulerAngles(0, 20, 0);
				a.mul(b);
				var v = new pc.Vec3();
				a.getEulerAngles(v);
				v.toStringFixed(4) == "[0.0000, 30.0000, 0.0000]";
			</test-js>
			
			<test-js>
				var a = new pc.Quat().setFromEulerAngles(0, 10, 0);
				var b = new pc.Quat().setFromEulerAngles(0, 20, 0);
				var c = new pc.Quat();
				c.mul2(a, b);
				var v = new pc.Vec3();
				c.getEulerAngles(v);
				v.toStringFixed(4) == "[0.0000, 30.0000, 0.0000]";
			</test-js>
			
			<test-js>
				var a = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				a.normalize();
				a.toStringFixed(4) == "[0.1826, 0.3651, 0.5477, 0.7303]";
			</test-js>
			
			<test-js>
				var a = new pc.Quat(0.1, 0.2, 0.3, 0.4);
				a.set(1, 2, 3, 4);
				a.toString(4) == "[1, 2, 3, 4]";
			</test-js>
			
			<test-js>
				var q = new pc.Quat();
				q.setFromAxisAngle(new pc.Vec3(0, 1, 0), 90);
				q.toStringFixed(4) == "[0.0000, 0.7071, 0.0000, 0.7071]";
			</test-js>
			
			<test-js>
				var q = new pc.Quat();
				q.setFromEulerAngles(45, 90, 180);
				q.toStringFixed(4) == "[-0.6533, 0.2706, 0.6533, 0.2706]";
			</test-js>
			
			<test-js>
				// Create a 4x4 rotation matrix of 180 degrees around the y-axis
				var rot = new pc.Mat4().setFromAxisAngle(pc.Vec3.UP, 180);
				// Convert to a quaternion
				var q = new pc.Quat().setFromMat4(rot);
			</test-js>
			
			<test-js>
				var q1 = new pc.Quat(-0.11,-0.15,-0.46,0.87);
				var q2 = new pc.Quat(-0.21,-0.21,-0.67,0.68);
				var a = new pc.Quat().slerp(q1, q2, 0);   // equals q1
				var b = new pc.Quat().slerp(q1, q2, 0.5); // midpoint interpolant
				var c = new pc.Quat().slerp(q1, q2, 1);   // equals q2
				a.toStringFixed(4) == q1.toStringFixed(4) &&
				c.toStringFixed(4) == q2.toStringFixed(4) &&
				b.toStringFixed(4) == "[-0.1619, -0.1821, -0.5716, 0.7840]";
			</test-js>
			
			<test-js>
				var v = new pc.Vec3(1, 2, 3);
				var q = new pc.Quat().setFromEulerAngles(10, 20, 30);
				var tv = q.transformVector(v);
				tv.toStringFixed(4) == "[1.0674, 2.2891, 2.7606]";
			</test-js>
			
			<test-js></test-js>
		</tests-js>



		<tests-js>
			<h1>Vec2 stuff</h1>		
			
			<test-js>
				var v = new pc.Vec2(1, 2);
				v.toString() == "[1, 2]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2(11, 22);
				a.add(b);
				a.toString() == "[12, 24]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2(11, 22);
				var c = (new pc.Vec2()).add2(a, b);
				c.toString() == "[12, 24]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = a.clone();
				a.toString() == b.toString();
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2();
				b.copy(a);
				a.toString() == b.toString();
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2(11, 22);
				a.dot(b) == 55;
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1, 1);
				var b = new pc.Vec2(1, 2);
				var c = new pc.Vec2(2, 1);
				var d = new pc.Vec2(2, 2);
				var all = [a, b, c, d];
				var tests = "";
				for (var i of all) {
					for (var j of all) {
						if (i.equals(j))
							tests += "1";
						else
							tests += "0";
					}
				}
				tests == "1000010000100001";
			</test-js>

			<test-js>
				var a = new pc.Vec2(1, 2)
				a.length().toFixed(4) == "2.2361";
			</test-js>

			<test-js>
				var a = new pc.Vec2(1, 2)
				a.lengthSq() == 5
			</test-js>

			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2(11, 22);
				var c = new pc.Vec2();
				c.lerp(a, b, 0.9);
				c.toString() == "[10, 20]";
			</test-js>

			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2(11, 22);
				a.mul(b);
				a.toString() == "[11, 44]";
			</test-js>

			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2(11, 22);
				var c = (new pc.Vec2()).mul2(a, b);
				c.toString() == "[11, 44]";
			</test-js>		
			
			<test-js>
				var a = new pc.Vec2(1,2);
				var b = new pc.Vec2(2,1);
				a.normalize();
				b.normalize();
				a.length() == b.length();
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1,2);
				a.scale(2).toString() == "[2, 4]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec2();
				a.set(1, 2);
				a.toString() == "[1, 2]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2(11, 22);
				a.sub(b);
				a.toString() == "[-10, -20]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec2(1, 2);
				var b = new pc.Vec2(11, 22);
				var c = (new pc.Vec2()).sub2(a, b);
				c.toString() == "[-10, -20]";
			</test-js>
			
			<test-js></test-js>
		</tests-js>



		<tests-js>
			<h1>Vec3 stuff</h1>

			<test-js>
				pc.Vec3.BACK.toString() == "[0, 0, 1]";
			</test-js>
			
			<test-js>
				pc.Vec3.DOWN.toString() == "[0, -1, 0]";
			</test-js>
			
			<test-js>
				pc.Vec3.FORWARD.toString() == "[0, 0, -1]";
			</test-js>
			
			<test-js>
				pc.Vec3.LEFT.toString() == "[-1, 0, 0]";
			</test-js>
			
			<test-js>
				pc.Vec3.ONE.toString() == "[1, 1, 1]";
			</test-js>
			
			<test-js>
				pc.Vec3.RIGHT.toString() == "[1, 0, 0]";
			</test-js>
			
			<test-js>
				pc.Vec3.UP.toString() == "[0, 1, 0]";
			</test-js>
			
			<test-js>
				pc.Vec3.ZERO.toString() == "[0, 0, 0]";
			</test-js>

			<test-js>
				var v = new pc.Vec3(1, 2, 3);
				v.toString() == "[1, 2, 3]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3(11, 22, 33);
				a.add(b);
				a.toString() == "[12, 24, 36]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3(11, 22, 33);
				var c = (new pc.Vec3()).add2(a, b);
				c.toString() == "[12, 24, 36]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = a.clone();
				a.toString() == b.toString();
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3();
				b.copy(a);
				a.toString() == b.toString();
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 0, 0);
				var b = new pc.Vec3(0, 1, 0);
				var c = new pc.Vec3();
				c.cross(a, b);
				c.toString() == "[0, 0, 1]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 2);
				var b = new pc.Vec3(11, 22, 33);
				a.dot(b) == 121;
			</test-js>

			<test-js>
				// copied from pc.Vec2, not testing last argument via permutation
				var a = new pc.Vec3(1, 1, 0);
				var b = new pc.Vec3(1, 2, 0);
				var c = new pc.Vec3(2, 1, 0);
				var d = new pc.Vec3(2, 2, 0);
				var all = [a, b, c, d];
				var tests = "";
				for (var i of all) {
					for (var j of all) {
						if (i.equals(j))
							tests += "1";
						else
							tests += "0";
					}
				}
				tests == "1000010000100001";
			</test-js>
			
			<test-js>
				var a = new pc.Vec3(1, 2, 3)
				// fails: a.length().toFixed(4) == "3.7416";
				a.length().toFixed(3) == "3.742";
			</test-js>
			
			<test-js>
				var a = new pc.Vec3(1, 2, 3)
				a.lengthSq() == 14;
			</test-js>
			
			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3(11, 22, 33);
				var c = new pc.Vec3();
				c.lerp(a, b, 0.9);
				c.toString() == "[10, 20, 30]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3(11, 22, 33);
				a.mul(b);
				a.toString() == "[11, 44, 99]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3(11, 22, 33);
				var c = (new pc.Vec3()).mul2(a, b);
				c.toString() == "[11, 44, 99]";
			</test-js>		

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3(3, 2, 1);
				a.normalize();
				b.normalize();
				a.length() == b.length();
			</test-js>

			<test-js>
				// copied from pc.Vec2, not testing last argument via permutation
				var a = new pc.Vec3(2, 3, 4);
				var b = new pc.Vec3(10, 10, 10);
				a.project(b);
				a.toString() == "[3, 3, 3]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				a.scale(2).toString() == "[2, 4, 6]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec3();
				a.set(1, 2, 3);
				a.toString() == "[1, 2, 3]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3(11, 22, 33);
				a.sub(b);
				a.toString() == "[-10, -20, -30]";
			</test-js>

			<test-js>
				var a = new pc.Vec3(1, 2, 3);
				var b = new pc.Vec3(11, 22, 33);
				var c = (new pc.Vec3()).sub2(a, b);
				c.toString() == "[-10, -20, -30]";
			</test-js>

			<test-js></test-js>
		</tests-js>



		<tests-js>
			<h1>Vec4 stuff</h1>

			<test-js>
				pc.Vec4.ONE.toString() == "[1, 1, 1, 1]";
			</test-js>

			<test-js>
				pc.Vec4.ZERO.toString() == "[0, 0, 0, 0]";
			</test-js>
			
			<test-js>
				var v = new pc.Vec4(1, 2, 3, 4);
				v.toString() == "[1, 2, 3, 4]";
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(11, 22, 33, 44);
				a.add(b);
				a.toString() == "[12, 24, 36, 48]";
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(11, 22, 33, 44);
				var c = (new pc.Vec4()).add2(a, b);
				c.toString() == "[12, 24, 36, 48]";
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = a.clone();
				a.toString() == b.toString();
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4();
				b.copy(a);
				a.toString() == b.toString();
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(11, 22, 33, 44);
				a.dot(b) == 330;
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 1, 0, 0);
				var b = new pc.Vec4(1, 2, 0, 0);
				var c = new pc.Vec4(2, 1, 0, 0);
				var d = new pc.Vec4(2, 2, 0, 0);
				var all = [a, b, c, d];
				var tests = "";
				for (var i of all) {
					for (var j of all) {
						if (i.equals(j))
							tests += "1";
						else
							tests += "0";
					}
				}
				tests == "1000010000100001";
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4)
				a.length().toFixed(4) == "5.4772";
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4)
				a.lengthSq() == 30;
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(11, 22, 33, 44);
				var c = new pc.Vec4();
				c.lerp(a, b, 0.9);
				c.toString() == "[10, 20, 30, 40]";
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(11, 22, 33, 44);
				a.mul(b);
				a.toString() == "[11, 44, 99, 176]";
			</test-js>

			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(11, 22, 33, 44);
				var c = (new pc.Vec4()).mul2(a, b);
				c.toString() == "[11, 44, 99, 176]";
			</test-js>		
			
			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(4, 3, 2, 1);
				a.normalize();
				b.normalize();
				a.length() == b.length();
			</test-js>
			
			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				a.scale(2).toString() == "[2, 4, 6, 8]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec4();
				a.set(1, 2, 3, 4);
				a.toString() == "[1, 2, 3, 4]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(11, 22, 33, 44);
				a.sub(b);
				a.toString() == "[-10, -20, -30, -40]";
			</test-js>
			
			<test-js>
				var a = new pc.Vec4(1, 2, 3, 4);
				var b = new pc.Vec4(11, 22, 33, 44);
				var c = (new pc.Vec4()).sub2(a, b);
				c.toString() == "[-10, -20, -30, -40]";
			</test-js>
			
			<test-js></test-js>
		</tests-js>

	</body>
</html>
